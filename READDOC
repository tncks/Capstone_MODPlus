//batchOrPhaseOrQueueingOrStackWayOrHashOrBucket(Data_structure)/StateMachineWay???/ContextManager?
            // 각 스레드별로 submit { ... } 작업을 제출시킴 그리고 나선? 공유자원은 한정되어 있고 static 하게 현재 구현이 되어있는데 어케 관리?
            // 집합이나 map 변수에 1단계 아주작은단위 task 끝난거 모아 누적 집계하다가 그 요소들의 총 개수가 최종 17000 에 달하면 조건만족시 그 다음 작업으로 넘어가게?

            // 스택에 공장 상태의 상수객체들을 17000개 넣어놓고 위에서부터 하나씩 덩어리단위로 빼서 꺼내 쓰기?
            // 스택에 삽입할 use case 는 없나? 그냥 빼서 쓰기만 하는 형태?.. 흠..
            // 스택을 떠올린 이유는 값을 원상복구 즉 원래 상태로 다시 쓸 수 있게 설계할 수 있어서. 이거 없으면 계속 전역변수 값 바뀌어버리고 여기저기서 접근일어난 후 막 섞여버릴테니깐..
            // dirtyBit 같은 boolean 변수 하나 추가로 옆에 같이 달아서 스택에 넣을 때 해당 스택 요소 값에 변경이 하나라도 일어나면 바로 dirty 상태로 설정? (이게 과연 좋은 접근법일까? 이것도 결국 전역변수 느낌이 있지 않을까?)
            // 스택을 순회할 때 위에서부터 우선 검사해서 dirty 인건 건너뛰고 깨끗한것중 가장 위에 거 pop() 해와서 그 받아온걸 여기 아래 context 상에서 적절히 쓰기 ? (흠)

            // 핵심: 전역변수 업데이트가 한번 일어나면 원래 초기 값을 기억해두지 않았기에 원상태로 돌아갈 수 없다.. -> 스택으로 이 문제를 해결하자가 이 접근법의 핵심
            // 전역변수 업데이트 하기 직전에 -> 스택에 전역변수 값을 PUSH. -> 전역변수 업데이트 -> 이것저것 하고 -> 전역변수 원상태로(pop해와서 세팅) 만들기
            // 근데 여기에 멀티 스레딩이라는 기법이 위 특성을 활용하며 동시적으로 적용되려면?
            // 정확히 언제 PUSH , 어느 케이스에서 POP ? 이것도 룰이나 원칙을 명확하게 정해놔야 하지 않을까 싶다.

            // Change note : 해결 완료.


            //// Collections.sort() 에서 race condition 이 생길 가능성.. static method 이기에.. 염두


            // 이슈 노트
            //
                    // Main issues and problematics analyzed : static functions and static global variables and shared resource.
                    // No problem with Constants.static final primitives but problem with Mutables.static shared variables.
                    // Solution -> Mutable data should have contextual memory and local data management way (stack, context, etc.)